"""
Audio Streaming Service v2.0
Handles YouTube audio streaming using yt-dlp with cookie authentication

CURRENT STATUS (October 2025):
- yt-dlp is currently broken for many YouTube music/label videos due to new protections
- PO Token extraction implemented via yt-dlp-get-pot plugin
- Most public Piped instances are down/unreliable; fallback remains for future resilience
- Service gracefully handles failures with accurate user feedback

FEATURES:
- Multiple yt-dlp strategies with robust error detection
- PO Token extraction via yt-dlp-get-pot plugin
- Piped fallback using public API
- Cookie-based authentication for yt-dlp and YouTube Music
- Strong error logging and user feedback

FUTURE:
- Self-hosted Piped; further fallback sources; automatic yt-dlp upgrade
"""
import logging
from typing import Dict, Any, Optional
import yt_dlp
import os
import tempfile
import httpx
import concurrent.futures

logger = logging.getLogger(__name__)

class AudioStreamingService:
    """Service for streaming YouTube audio with cookie authentication and Piped fallback"""

    def __init__(self, cookie: Optional[str] = None, youtube_music_aggregator: Optional[Any] = None):
        """
        Initialize the audio streaming service
        
        Args:
            cookie: YouTube Music cookie string for authentication
            youtube_music_aggregator: YouTube Music aggregator instance for authenticated streaming
        """
        self.cache = {}
        self.cookie = cookie
        self.youtube_music_aggregator = youtube_music_aggregator
        self.cookie_file = None
        if self.cookie:
            self._create_cookie_file()

    def _create_cookie_file(self):
        """Create a temp cookie file in Netscape format for yt-dlp"""
        try:
            self.cookie_file = tempfile.NamedTemporaryFile(
                mode='w', suffix='.txt', delete=False
            )
            self.cookie_file.write("# Netscape HTTP Cookie File\n")
            self.cookie_file.write("# This file is generated by yt-dlp.  Do not edit.\n\n")
            cookie_pairs = self.cookie.split('; ')
            for pair in cookie_pairs:
                if '=' in pair:
                    name, value = pair.split('=', 1)
                    is_secure = name.startswith('__Secure-') or name.startswith('__Host-')
                    secure_flag = 'TRUE' if is_secure else 'FALSE'
                    expiration = '2000000000'
                    self.cookie_file.write(
                        f".youtube.com\tTRUE\t/\t{secure_flag}\t{expiration}\t{name}\t{value}\n"
                    )
                    self.cookie_file.write(
                        f".music.youtube.com\tTRUE\t/\t{secure_flag}\t{expiration}\t{name}\t{value}\n"
                    )
            self.cookie_file.close()
            logger.info(f"[AudioStream] Created cookie file with {len(cookie_pairs)} cookies")
        except Exception as e:
            logger.error(f"[AudioStream] Failed to create cookie file: {e}")
            self.cookie_file = None

    async def get_stream_url(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Get direct stream URL with yt-dlp, fallback to Piped if needed"""
        strategies = [
            self._try_youtube_music_authenticated,  # NEW: Use YouTube Music aggregator auth first
            self._try_youtube_url_no_auth,
            self._try_youtube_music_url,
            self._try_youtube_url_authenticated,
            self._try_basic_extraction,
            self._try_piped_fallback  # Robust fallback
        ]
        for i, strategy in enumerate(strategies, 1):
            try:
                logger.info(f"[AudioStream] Strategy {i}: Trying {strategy.__name__} for {video_id}")
                result = await strategy(video_id)
                if result:
                    # Check if this is a YouTube protection error
                    if result.get('error') == 'YOUTUBE_PROTECTION':
                        # Return the protection error immediately - don't try other strategies
                        # as they will all fail with the same issue
                        logger.warning(f"[AudioStream] YouTube protection detected - stopping strategy attempts")
                        return result
                    # Check if we got a successful stream URL
                    if result.get("url"):
                        return result
            except Exception as e:
                logger.warning(f"[AudioStream] Strategy {i} failed: {e}")
                continue
        logger.error(f"[AudioStream] All strategies failed for {video_id}")
        return None

    async def _try_youtube_music_authenticated(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Try using YouTube Music aggregator's authentication for yt-dlp"""
        if not self.youtube_music_aggregator:
            logger.debug("[AudioStream] No YouTube Music aggregator available")
            return None

        try:
            # Get fresh authentication headers from the aggregator
            auth_headers = self.youtube_music_aggregator._generate_fresh_sapisid_hash()

            # Use yt-dlp with the aggregator's authentication - try multiple client configurations
            client_configs = [
                # Most aggressive - try web client first
                {
                    'player_client': ['web', 'android_music', 'ios'],
                    'player_skip': ['js', 'webpage'],
                },
                # Fallback to android clients
                {
                    'player_client': ['android_music', 'android', 'ios'],
                    'player_skip': ['webpage'],
                },
                # Last resort - just android
                {
                    'player_client': ['android'],
                    'player_skip': [],
                }
            ]

            for i, client_config in enumerate(client_configs):
                try:
                    ydl_opts = {
                        'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
                        'quiet': True,
                        'no_warnings': True,
                        'extract_flat': False,
                        'ignoreerrors': False,
                        'cookiefile': self.youtube_music_aggregator.cookie_file.name if self.youtube_music_aggregator.cookie_file else None,
                        'http_headers': {
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36',
                            'Accept': '*/*',
                            'Accept-Language': 'en-US,en;q=0.9',
                            'Accept-Encoding': 'gzip, deflate, br',
                            'Origin': 'https://music.youtube.com',
                            'Referer': 'https://music.youtube.com/',
                            'Sec-Fetch-Dest': 'audio',
                            'Sec-Fetch-Mode': 'no-cors',
                            'Sec-Fetch-Site': 'cross-site',
                            'sec-ch-ua': '"Chromium";v="130", "Google Chrome";v="130", "Not:A-Brand";v="99"',
                            'sec-ch-ua-arch': '"x86"',
                            'sec-ch-ua-bitness': '"64"',
                            'sec-ch-ua-form-factors': '"Desktop"',
                            'sec-ch-ua-full-version': '"130.0.6723.58"',
                            'sec-ch-ua-full-version-list': '"Chromium";v="130.0.6723.58", "Google Chrome";v="130.0.6723.58", "Not:A-Brand";v="99.0.0.0"',
                            'sec-ch-ua-mobile': '?0',
                            'sec-ch-ua-model': '""',
                            'sec-ch-ua-platform': '"Windows"',
                            'sec-ch-ua-platform-version': '"15.0.0"',
                            'sec-ch-ua-wow64': '?0',
                        },
                        'extractor_args': {'youtube': client_config}
                    }

                    # Add fresh authentication headers
                    if auth_headers:
                        ydl_opts['http_headers'].update(auth_headers)

                    # Extract URL directly
                    import concurrent.futures

                    def extract_url():
                        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                            info = ydl.extract_info(f'https://music.youtube.com/watch?v={video_id}', download=False)
                            if info and info.get('url'):
                                return {
                                    'url': info['url'],
                                    'format_id': info.get('format_id'),
                                    'ext': info.get('ext'),
                                    'bitrate': info.get('abr') or info.get('tbr'),
                                    'duration': info.get('duration'),
                                    'title': info.get('title')
                                }
                        return None

                    # Run in thread pool
                    with concurrent.futures.ThreadPoolExecutor() as executor:
                        future = executor.submit(extract_url)
                        result = future.result(timeout=30)

                    if result:
                        logger.info(f"[AudioStream] ✓ YouTube Music authenticated extraction successful (client config {i+1})")
                        return {
                            **result,
                            'strategy': 'youtube_music_authenticated'
                        }

                except Exception as e:
                    logger.debug(f"[AudioStream] Client config {i+1} failed: {e}")
                    continue

            logger.warning("[AudioStream] All YouTube Music authenticated client configs failed")
            return None

        except Exception as e:
            logger.warning(f"[AudioStream] YouTube Music authenticated extraction error: {e}")
            return None

    async def _try_youtube_music_url(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Try YouTube Music URL with authentication"""
        if not self.cookie_file:
            raise Exception("No cookie file available")

        ydl_opts = {
            'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
            'quiet': True,
            'no_warnings': True,
            'cookiefile': self.cookie_file.name,
            'extract_flat': False,
            'ignoreerrors': False,
            # Handle YouTube's new restrictions
            'extractor_args': {
                'youtube': {
                    'player_client': ['mweb', 'android_music'],
                    'player_skip': ['webpage'],
                }
            },
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
                'Accept': '*/*',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br',
                'Origin': 'https://music.youtube.com',
                'Referer': 'https://music.youtube.com/',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'same-origin',
                'Sec-Fetch-Site': 'same-origin',
                'sec-ch-ua': '"Chromium";v="140", "Not=A?Brand";v="24", "Google Chrome";v="140"',
                'sec-ch-ua-arch': '"arm"',
                'sec-ch-ua-bitness': '"64"',
                'sec-ch-ua-form-factors': '"Desktop"',
                'sec-ch-ua-full-version': '"140.0.7339.186"',
                'sec-ch-ua-full-version-list': '"Chromium";v="140.0.7339.186", "Not=A?Brand";v="24.0.0.0", "Google Chrome";v="140.0.7339.186"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-model': '""',
                'sec-ch-ua-platform': '"macOS"',
                'sec-ch-ua-platform-version': '"26.0.1"',
                'sec-ch-ua-wow64': '?0',
            },
        }

        url = f"https://music.youtube.com/watch?v={video_id}"
        return await self._extract_with_opts(url, ydl_opts, "Music URL (authenticated)")

    async def _try_youtube_url_authenticated(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Try regular YouTube URL with authentication"""
        if not self.cookie_file:
            raise Exception("No cookie file available")

        ydl_opts = {
            'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
            'quiet': True,
            'no_warnings': True,
            'cookiefile': self.cookie_file.name,
            'extract_flat': False,
            'ignoreerrors': False,
            # Handle YouTube's new restrictions
            'extractor_args': {
                'youtube': {
                    'player_client': ['mweb', 'android'],
                    'player_skip': ['webpage'],
                }
            },
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
                'Accept': '*/*',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br',
                'Referer': 'https://www.youtube.com/',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-origin',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
        }

        url = f"https://www.youtube.com/watch?v={video_id}"
        return await self._extract_with_opts(url, ydl_opts, "YouTube URL (authenticated)")

    async def _try_youtube_url_no_auth(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Try regular YouTube URL without authentication - updated for 2025 protections"""
        # Try multiple client configurations to bypass YouTube's protections
        client_configs = [
            # Try web client first (most likely to work)
            {
                'player_client': ['web', 'android', 'ios'],
                'player_skip': ['js', 'webpage'],
            },
            # Fallback to android clients
            {
                'player_client': ['android', 'ios', 'mweb'],
                'player_skip': ['webpage'],
            },
            # Last resort - just android
            {
                'player_client': ['android'],
                'player_skip': [],
            }
        ]

        for i, client_config in enumerate(client_configs):
            try:
                ydl_opts = {
                    'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
                    'quiet': True,
                    'no_warnings': True,
                    'extract_flat': False,
                    'ignoreerrors': False,
                    'age_limit': None,
                    'extractor_args': {'youtube': client_config},
                    'http_headers': {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36',
                        'Accept': '*/*',
                        'Accept-Language': 'en-US,en;q=0.9',
                        'Accept-Encoding': 'gzip, deflate, br',
                        'DNT': '1',
                        'Connection': 'keep-alive',
                        'Upgrade-Insecure-Requests': '1',
                        'sec-ch-ua': '"Chromium";v="130", "Google Chrome";v="130", "Not:A-Brand";v="99"',
                        'sec-ch-ua-arch': '"x86"',
                        'sec-ch-ua-bitness': '"64"',
                        'sec-ch-ua-form-factors': '"Desktop"',
                        'sec-ch-ua-full-version': '"130.0.6723.58"',
                        'sec-ch-ua-full-version-list': '"Chromium";v="130.0.6723.58", "Google Chrome";v="130.0.6723.58", "Not:A-Brand";v="99.0.0.0"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-model': '""',
                        'sec-ch-ua-platform': '"Windows"',
                        'sec-ch-ua-platform-version': '"15.0.0"',
                        'sec-ch-ua-wow64': '?0',
                    },
                }

                url = f"https://www.youtube.com/watch?v={video_id}"
                result = await self._extract_with_opts(url, ydl_opts, f"YouTube URL (no auth, config {i+1})")
                if result:
                    return result

            except Exception as e:
                logger.debug(f"[AudioStream] No-auth config {i+1} failed: {e}")
                continue

        return None

    async def _try_basic_extraction(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Try most basic extraction possible with multiple client fallbacks - updated for 2025"""
        # Try different client configurations
        client_configs = [
            # Web client with modern headers
            {
                'player_client': ['web', 'android', 'ios'],
                'player_skip': ['js', 'webpage'],
            },
            # Android music client
            {
                'player_client': ['android_music', 'android', 'ios'],
                'player_skip': ['webpage'],
            },
            # TV embedded (often works when others don't)
            {
                'player_client': ['tv_embedded'],
                'player_skip': [],
            },
            # Minimal android
            {
                'player_client': ['android'],
                'player_skip': [],
            }
        ]

        for i, client_config in enumerate(client_configs):
            try:
                ydl_opts = {
                    'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
                    'quiet': False,  # Enable output to see what's happening
                    'extract_flat': False,
                    'ignoreerrors': True,
                    'no_check_certificate': True,
                    'extractor_args': {'youtube': client_config},
                    'http_headers': {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36',
                        'Accept': '*/*',
                        'Accept-Language': 'en-US,en;q=0.9',
                        'Accept-Encoding': 'gzip, deflate, br',
                        'DNT': '1',
                        'Connection': 'keep-alive',
                        'sec-ch-ua': '"Chromium";v="130", "Google Chrome";v="130", "Not:A-Brand";v="99"',
                        'sec-ch-ua-arch': '"x86"',
                        'sec-ch-ua-bitness': '"64"',
                        'sec-ch-ua-form-factors': '"Desktop"',
                        'sec-ch-ua-full-version': '"130.0.6723.58"',
                        'sec-ch-ua-full-version-list': '"Chromium";v="130.0.6723.58", "Google Chrome";v="130.0.6723.58", "Not:A-Brand";v="99.0.0.0"',
                        'sec-ch-ua-mobile': '?0',
                        'sec-ch-ua-model': '""',
                        'sec-ch-ua-platform': '"Windows"',
                        'sec-ch-ua-platform-version': '"15.0.0"',
                        'sec-ch-ua-wow64': '?0',
                    },
                }

                if self.cookie_file:
                    ydl_opts['cookiefile'] = self.cookie_file.name

                url = f"https://www.youtube.com/watch?v={video_id}"
                result = await self._extract_with_opts(url, ydl_opts, f"_try_basic_extraction (config {i+1})")
                if result:
                    return result

            except Exception as e:
                logger.debug(f"[AudioStream] Basic extraction config {i+1} failed: {e}")
                continue

        return None

    async def _extract_with_opts(self, url: str, ydl_opts: dict, strategy_name: str) -> Optional[Dict[str, Any]]:
        """Common extraction logic with enhanced error handling for YouTube protections - updated for 2025"""
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

                if not info:
                    raise Exception(f"No info returned")

                # Get the stream URL
                stream_url = info.get('url')

                if stream_url:
                    logger.info(f"[AudioStream] ✓ {strategy_name} success - format: {info.get('format_id')}, ext: {info.get('ext')}")

                    return {
                        'url': stream_url,
                        'format_id': info.get('format_id'),
                        'ext': info.get('ext'),
                        'bitrate': info.get('abr') or info.get('tbr'),
                        'duration': info.get('duration'),
                        'title': info.get('title'),
                        'strategy': strategy_name
                    }

                # Try to extract from formats manually
                formats = info.get('formats', [])
                if formats:
                    # Get the first available format with a URL
                    for fmt in formats:
                        if fmt.get('url'):
                            logger.info(f"[AudioStream] ✓ {strategy_name} success (manual format selection) - format: {fmt.get('format_id')}")
                            return {
                                'url': fmt['url'],
                                'format_id': fmt.get('format_id'),
                                'ext': fmt.get('ext'),
                                'bitrate': fmt.get('abr') or fmt.get('tbr'),
                                'duration': info.get('duration'),
                                'title': info.get('title'),
                                'strategy': strategy_name
                            }

                raise Exception("No stream URL found in any format")

        except yt_dlp.DownloadError as e:
            err_msg = str(e)

            # Check for various YouTube protection/signature/PO Token errors
            protection_indicators = [
                "unable to extract player response",
                "No PO Token provided",
                "Failed to extract any player response",
                "Signature extraction failed",
                "Failed to parse JSON",
                "Only images are available for download",
                "Video unavailable",
                "Sign in to confirm you're not a bot",
                "This video requires payment",
                "This video is not available",
                "private video",
                "This video has been removed"
            ]

            if any(indicator.lower() in err_msg.lower() for indicator in protection_indicators):
                logger.warning(f"[AudioStream] YouTube protection detected in {strategy_name}: {err_msg[:200]}")
                # Return structured error for UI to handle gracefully
                return {
                    'error': 'YOUTUBE_PROTECTION',
                    'error_message': (
                        'This audio is temporarily protected by YouTube '
                        'and cannot be streamed with current yt-dlp. '
                        'Please try again later or use a different video.'
                    ),
                    'strategy': strategy_name,
                    'technical_details': err_msg[:200]  # Truncate for safety
                }

            # Legacy fallback for format issues
            if "Requested format is not available" in err_msg:
                logger.warning(f"[AudioStream] {strategy_name}: Format not available, trying list-formats approach")
                return await self._try_any_format(url, strategy_name)

            # Re-raise other download errors
            raise e

        except Exception as e:
            # Handle other types of errors
            err_msg = str(e)
            if "HTTP Error 429" in err_msg or "rate limit" in err_msg.lower():
                logger.warning(f"[AudioStream] Rate limited in {strategy_name}: {err_msg}")
                return {
                    'error': 'RATE_LIMIT',
                    'error_message': 'YouTube rate limit exceeded. Please try again later.',
                    'strategy': strategy_name,
                    'technical_details': err_msg[:200]
                }
            elif "HTTP Error 403" in err_msg:
                logger.warning(f"[AudioStream] Access denied in {strategy_name}: {err_msg}")
                return {
                    'error': 'ACCESS_DENIED',
                    'error_message': 'Access denied by YouTube. Video may be private or region-locked.',
                    'strategy': strategy_name,
                    'technical_details': err_msg[:200]
                }
            else:
                logger.warning(f"[AudioStream] Unexpected error in {strategy_name}: {err_msg}")
                raise

    async def _try_any_format(self, url: str, strategy_name: str) -> Optional[Dict[str, Any]]:
        """Last resort: try to get any available format"""
        try:
            ydl_opts = {
                'quiet': True,
                'listformats': True,
                'no_warnings': True,
            }

            if self.cookie_file:
                ydl_opts['cookiefile'] = self.cookie_file.name

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

                formats = info.get('formats', [])
                if not formats:
                    raise Exception("No formats available")

                # Try each format until one works
                for fmt in formats:
                    if fmt.get('acodec') != 'none':  # Has audio
                        try:
                            format_id = fmt.get('format_id')
                            ydl_opts_single = {
                                'format': format_id,
                                'quiet': True,
                                'no_warnings': True,
                            }

                            if self.cookie_file:
                                ydl_opts_single['cookiefile'] = self.cookie_file.name

                            with yt_dlp.YoutubeDL(ydl_opts_single) as ydl_single:
                                info_single = ydl_single.extract_info(url, download=False)

                                if info_single and info_single.get('url'):
                                    logger.info(f"[AudioStream] ✓ {strategy_name} success with format {format_id}")
                                    return {
                                        'url': info_single['url'],
                                        'format_id': format_id,
                                        'ext': info_single.get('ext'),
                                        'bitrate': info_single.get('abr') or info_single.get('tbr'),
                                        'duration': info_single.get('duration'),
                                        'title': info_single.get('title'),
                                        'strategy': f"{strategy_name} (format {format_id})"
                                    }
                        except Exception as e:
                            logger.debug(f"[AudioStream] Format {format_id} failed: {e}")
                            continue

                raise Exception("No working format found")

        except Exception as e:
            logger.error(f"[AudioStream] Any-format fallback failed: {e}")
            return None

    async def _try_piped_fallback(self, video_id: str) -> Optional[Dict[str, Any]]:
        """
        Piped fallback: try known public instances if yt-dlp extraction fails.
        Note: As of October 2025, most public Piped instances are unreliable.
        """
        piped_instances = [
            "https://pipedapi.kavin.rocks",
            # More as available, e.g: "https://pipedapi.adminforge.de"
        ]
        logger.info(f"[AudioStream] Trying Piped fallback for {video_id}")
        for piped_url in piped_instances:
            try:
                api_url = f"{piped_url}/streams/{video_id}"
                async with httpx.AsyncClient(timeout=10.0, follow_redirects=True) as client:
                    response = await client.get(api_url)
                    # Handle redirects
                    if response.status_code in (301, 302, 307, 308):
                        redirect_url = response.headers.get('Location')
                        if redirect_url:
                            if redirect_url.startswith('/'):
                                redirect_url = f"{piped_url}{redirect_url}"
                            response = await client.get(redirect_url)
                    if response.status_code == 200:
                        try:
                            data = response.json()
                        except Exception as e:
                            logger.debug(f"[AudioStream] Failed to parse JSON from {piped_url}: {e}")
                            continue
                        if not data.get('title') or not data.get('duration'):
                            continue
                        audio_streams = data.get('audioStreams', [])
                        if not audio_streams:
                            continue
                        best_audio = max(audio_streams, key=lambda x: x.get('bitrate', 0) or 0)
                        if best_audio and best_audio.get('url'):
                            logger.info(f"[AudioStream] ✓ Piped fallback: {best_audio.get('bitrate')}bps from {piped_url}")
                            return {
                                'url': best_audio['url'],
                                'format_id': best_audio.get('format', 'piped'),
                                'ext': best_audio.get('codec', 'unknown'),
                                'bitrate': best_audio.get('bitrate'),
                                'duration': data.get('duration'),
                                'title': data.get('title'),
                                'strategy': f'piped_fallback ({piped_url})'
                            }
            except httpx.TimeoutException:
                logger.debug(f"[AudioStream] Timeout connecting to {piped_url}")
            except httpx.ConnectError:
                logger.debug(f"[AudioStream] Connection failed to {piped_url}")
            except Exception as e:
                logger.debug(f"[AudioStream] Piped instance {piped_url} error: {e}")
                continue
        logger.warning("[AudioStream] All Piped instances failed (expected Oct 2025).")
        return None

    def __del__(self):
        """Cleanup cookie file on deletion"""
        if self.cookie_file and os.path.exists(self.cookie_file.name):
            try:
                os.unlink(self.cookie_file.name)
                logger.info(f"[AudioStream] Cleaned up cookie file")
            except Exception as e:
                logger.error(f"[AudioStream] Failed to cleanup cookie file: {e}")

# --- yt-dlp ISSUES/STATUS RESEARCH (Oct 2025): ---
#
# - Breaking extraction errors tracked on:
#   https://github.com/yt-dlp/yt-dlp/issues/
#   Announcement & FAQ: #14404, #3766
# - Protections: "No PO Token", "unable to extract player version"
# - Solutions: Wait for yt-dlp update; follow official issues; no working universal workaround yet
#
# - Piped: https://github.com/TeamPiped/Piped
#   API: https://docs.piped.video/docs/api-documentation/
#   Instance status: Many public endpoints are unreliable; self-host for best fallback
