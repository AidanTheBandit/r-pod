"""
Audio Streaming Service v2.0
Handles YouTube audio streaming using yt-dlp with cookie authentication

CURRENT STATUS (October 2025):
- yt-dlp is currently broken due to YouTube's new extraction protections
- Most public Piped instances are down/unreliable
- Service gracefully handles these failures with user-friendly error messages

IMPLEMENTED FEATURES:
- Multiple yt-dlp extraction strategies with different client configurations
- YouTube protection error detection and graceful handling
- Piped API fallback (currently limited by instance availability)
- Cookie-based authentication for YouTube Music
- Comprehensive error logging and user feedback

FUTURE IMPROVEMENTS:
- Self-hosted Piped instance for reliable fallback
- Alternative streaming services (Invidious, etc.)
- Automatic yt-dlp updates when YouTube protections are bypassed
"""
import logging
from typing import Dict, Any, Optional
import yt_dlp
import os
import tempfile
import httpx

logger = logging.getLogger(__name__)

class AudioStreamingService:
    """Service for streaming YouTube audio with cookie authentication"""
    
    def __init__(self, cookie: Optional[str] = None):
        """
        Initialize the audio streaming service
        
        Args:
            cookie: YouTube Music cookie string for authentication
        """
        self.cache = {}
        self.cookie = cookie
        self.cookie_file = None
        
        if self.cookie:
            self._create_cookie_file()
    
    def _create_cookie_file(self):
        """Create a temporary cookie file for yt-dlp in Netscape format"""
        try:
            self.cookie_file = tempfile.NamedTemporaryFile(
                mode='w', 
                suffix='.txt',
                delete=False
            )
            
            # Write Netscape cookie header
            self.cookie_file.write("# Netscape HTTP Cookie File\n")
            self.cookie_file.write("# This file is generated by yt-dlp.  Do not edit.\n\n")
            
            # Parse cookie string and write in proper Netscape format
            cookie_pairs = self.cookie.split('; ')
            
            for pair in cookie_pairs:
                if '=' in pair:
                    name, value = pair.split('=', 1)
                    
                    # Determine if this is a secure cookie
                    is_secure = name.startswith('__Secure-') or name.startswith('__Host-')
                    secure_flag = 'TRUE' if is_secure else 'FALSE'
                    
                    # Set expiration far in the future (10 years)
                    expiration = '2000000000'
                    
                    # Write for both youtube.com and music.youtube.com
                    self.cookie_file.write(
                        f".youtube.com\tTRUE\t/\t{secure_flag}\t{expiration}\t{name}\t{value}\n"
                    )
                    self.cookie_file.write(
                        f".music.youtube.com\tTRUE\t/\t{secure_flag}\t{expiration}\t{name}\t{value}\n"
                    )
            
            self.cookie_file.close()
            logger.info(f"[AudioStream] Created cookie file with {len(cookie_pairs)} cookies")
            
        except Exception as e:
            logger.error(f"[AudioStream] Failed to create cookie file: {e}")
            self.cookie_file = None
    
    async def get_stream_url(self, video_id: str) -> Optional[Dict[str, Any]]:
        """
        Get the direct stream URL for a YouTube video with multiple fallback strategies
        
        Args:
            video_id: YouTube video ID
            
        Returns:
            Dictionary with stream info or None
        """
        # Try multiple strategies in order of preference
        strategies = [
            self._try_youtube_url_no_auth,  # Fastest working strategy first
            self._try_youtube_music_url,
            self._try_youtube_url_authenticated,
            self._try_basic_extraction,
            self._try_piped_fallback  # Last resort: Piped API
        ]
        
        for i, strategy in enumerate(strategies, 1):
            try:
                logger.info(f"[AudioStream] Strategy {i}: Trying {strategy.__name__} for {video_id}")
                result = await strategy(video_id)
                if result:
                    return result
            except Exception as e:
                logger.warning(f"[AudioStream] Strategy {i} failed: {e}")
                continue
        
        logger.error(f"[AudioStream] All strategies failed for {video_id}")
        return None
    
    async def _try_youtube_music_url(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Try YouTube Music URL with authentication"""
        if not self.cookie_file:
            raise Exception("No cookie file available")
        
        ydl_opts = {
            'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
            'quiet': True,
            'no_warnings': True,
            'cookiefile': self.cookie_file.name,
            'extract_flat': False,
            'ignoreerrors': False,
            # Handle YouTube's new restrictions
            'extractor_args': {
                'youtube': {
                    'player_client': ['android_music', 'web_music'],
                    'player_skip': ['js', 'configs'],
                }
            },
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
                'Accept': '*/*',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br',
                'Origin': 'https://music.youtube.com',
                'Referer': 'https://music.youtube.com/',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'same-origin',
                'Sec-Fetch-Site': 'same-origin',
                'sec-ch-ua': '"Chromium";v="140", "Not=A?Brand";v="24", "Google Chrome";v="140"',
                'sec-ch-ua-arch': '"arm"',
                'sec-ch-ua-bitness': '"64"',
                'sec-ch-ua-form-factors': '"Desktop"',
                'sec-ch-ua-full-version': '"140.0.7339.186"',
                'sec-ch-ua-full-version-list': '"Chromium";v="140.0.7339.186", "Not=A?Brand";v="24.0.0.0", "Google Chrome";v="140.0.7339.186"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-model': '""',
                'sec-ch-ua-platform': '"macOS"',
                'sec-ch-ua-platform-version': '"26.0.1"',
                'sec-ch-ua-wow64': '?0',
            },
        }
        
        url = f"https://music.youtube.com/watch?v={video_id}"
        return await self._extract_with_opts(url, ydl_opts, "Music URL (authenticated)")
    
    async def _try_youtube_url_authenticated(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Try regular YouTube URL with authentication"""
        if not self.cookie_file:
            raise Exception("No cookie file available")
        
        ydl_opts = {
            'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
            'quiet': True,
            'no_warnings': True,
            'cookiefile': self.cookie_file.name,
            'extract_flat': False,
            'ignoreerrors': False,
            # Handle YouTube's new restrictions
            'extractor_args': {
                'youtube': {
                    'player_client': ['android', 'web'],
                    'player_skip': ['js', 'configs'],
                }
            },
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
                'Accept': '*/*',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br',
                'Referer': 'https://www.youtube.com/',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-origin',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
        }
        
        url = f"https://www.youtube.com/watch?v={video_id}"
        return await self._extract_with_opts(url, ydl_opts, "YouTube URL (authenticated)")
    
    async def _try_youtube_url_no_auth(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Try regular YouTube URL without authentication"""
        ydl_opts = {
            'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
            'quiet': True,
            'no_warnings': True,
            'extract_flat': False,
            'ignoreerrors': False,
            'age_limit': None,
            # Handle YouTube's new restrictions
            'extractor_args': {
                'youtube': {
                    'player_client': ['android', 'web'],
                    'player_skip': ['js', 'configs'],
                }
            },
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
                'Accept': '*/*',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
        }
        
        url = f"https://www.youtube.com/watch?v={video_id}"
        return await self._extract_with_opts(url, ydl_opts, "YouTube URL (no auth)")
    
    async def _try_basic_extraction(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Try most basic extraction possible with multiple client fallbacks"""
        # Try different client configurations
        clients_to_try = [
            {'player_client': ['android', 'web'], 'player_skip': ['js', 'configs']},
            {'player_client': ['ios', 'web'], 'player_skip': ['js']},
            {'player_client': ['tvhtml5', 'web'], 'player_skip': []},
        ]
        
        for i, client_config in enumerate(clients_to_try):
            try:
                ydl_opts = {
                    'format': 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
                    'quiet': False,  # Enable output to see what's happening
                    'extract_flat': False,
                    'ignoreerrors': True,
                    'no_check_certificate': True,
                    'extractor_args': {'youtube': client_config},
                    'http_headers': {
                        'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
                        'Accept': '*/*',
                        'Accept-Language': 'en-US,en;q=0.9',
                        'Accept-Encoding': 'gzip, deflate, br',
                        'DNT': '1',
                        'Connection': 'keep-alive',
                    },
                }
                
                if self.cookie_file:
                    ydl_opts['cookiefile'] = self.cookie_file.name
                
                url = f"https://www.youtube.com/watch?v={video_id}"
                result = await self._extract_with_opts(url, ydl_opts, f"_try_basic_extraction (client {i+1})")
                if result:
                    return result
                    
            except Exception as e:
                logger.debug(f"[AudioStream] Basic extraction client {i+1} failed: {e}")
                continue
        
        return None
    
    async def _extract_with_opts(self, url: str, ydl_opts: dict, strategy_name: str) -> Optional[Dict[str, Any]]:
        """Common extraction logic with enhanced error handling for YouTube protections"""
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

                if not info:
                    raise Exception(f"No info returned")

                # Get the stream URL
                stream_url = info.get('url')

                if stream_url:
                    logger.info(f"[AudioStream] ✓ {strategy_name} success - format: {info.get('format_id')}, ext: {info.get('ext')}")

                    return {
                        'url': stream_url,
                        'format_id': info.get('format_id'),
                        'ext': info.get('ext'),
                        'bitrate': info.get('abr') or info.get('tbr'),
                        'duration': info.get('duration'),
                        'title': info.get('title'),
                        'strategy': strategy_name
                    }

                # Try to extract from formats manually
                formats = info.get('formats', [])
                if formats:
                    # Get the first available format with a URL
                    for fmt in formats:
                        if fmt.get('url'):
                            logger.info(f"[AudioStream] ✓ {strategy_name} success (manual format selection) - format: {fmt.get('format_id')}")
                            return {
                                'url': fmt['url'],
                                'format_id': fmt.get('format_id'),
                                'ext': fmt.get('ext'),
                                'bitrate': fmt.get('abr') or fmt.get('tbr'),
                                'duration': info.get('duration'),
                                'title': info.get('title'),
                                'strategy': strategy_name
                            }

                raise Exception("No stream URL found in any format")

        except yt_dlp.DownloadError as e:
            err_msg = str(e)

            # Check for YouTube protection/signature/PO Token errors
            if (
                "unable to extract player version" in err_msg or
                "No PO Token provided" in err_msg or
                "Failed to extract any player response" in err_msg or
                "Signature extraction failed" in err_msg or
                "Failed to parse JSON" in err_msg or
                "Only images are available for download" in err_msg
            ):
                logger.error(f"[AudioStream] YT-dlp extraction blocked by YouTube protections: {err_msg}")
                # Return structured error for UI to handle gracefully
                return {
                    'error': 'YOUTUBE_PROTECTION',
                    'error_message': (
                        'This audio is temporarily protected by YouTube '
                        'and cannot be streamed with current yt-dlp. '
                        'Please try again after a future yt-dlp update.'
                    ),
                    'strategy': strategy_name,
                    'technical_details': err_msg[:200]  # Truncate for safety
                }

            # Legacy fallback for format issues
            if "Requested format is not available" in err_msg:
                logger.warning(f"[AudioStream] {strategy_name}: Format not available, trying list-formats approach")
                return await self._try_any_format(url, strategy_name)

            # Re-raise other download errors
            raise e
    
    async def _try_any_format(self, url: str, strategy_name: str) -> Optional[Dict[str, Any]]:
        """Last resort: try to get any available format"""
        try:
            ydl_opts = {
                'quiet': True,
                'listformats': True,
                'no_warnings': True,
            }
            
            if self.cookie_file:
                ydl_opts['cookiefile'] = self.cookie_file.name
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                
                formats = info.get('formats', [])
                if not formats:
                    raise Exception("No formats available")
                
                # Try each format until one works
                for fmt in formats:
                    if fmt.get('acodec') != 'none':  # Has audio
                        try:
                            format_id = fmt.get('format_id')
                            ydl_opts_single = {
                                'format': format_id,
                                'quiet': True,
                                'no_warnings': True,
                            }
                            
                            if self.cookie_file:
                                ydl_opts_single['cookiefile'] = self.cookie_file.name
                            
                            with yt_dlp.YoutubeDL(ydl_opts_single) as ydl_single:
                                info_single = ydl_single.extract_info(url, download=False)
                                
                                if info_single and info_single.get('url'):
                                    logger.info(f"[AudioStream] ✓ {strategy_name} success with format {format_id}")
                                    return {
                                        'url': info_single['url'],
                                        'format_id': format_id,
                                        'ext': info_single.get('ext'),
                                        'bitrate': info_single.get('abr') or info_single.get('tbr'),
                                        'duration': info_single.get('duration'),
                                        'title': info_single.get('title'),
                                        'strategy': f"{strategy_name} (format {format_id})"
                                    }
                        except Exception as e:
                            logger.debug(f"[AudioStream] Format {format_id} failed: {e}")
                            continue
                
                raise Exception("No working format found")
                
        except Exception as e:
            logger.error(f"[AudioStream] Any-format fallback failed: {e}")
            return None
    
    async def _try_piped_fallback(self, video_id: str) -> Optional[Dict[str, Any]]:
        """Last resort: Use Piped API as fallback when yt-dlp fails
        
        NOTE: Most public Piped instances are currently unreliable or down.
        This fallback is kept for when instances become available again.
        For production use, consider self-hosting a Piped instance.
        """
        try:
            # Known Piped instances (many are currently down/unreliable as of Oct 2025)
            piped_instances = [
                "https://pipedapi.kavin.rocks",  # Official/main instance
                # Other instances often return 301, 404, 502, 522, 525, or SSL errors
                # "https://pipedapi.libreho.st",  # Often down
                # "https://pipedapi.r4fo.com",     # Often 404
                # Add more as they become available and tested
            ]
            
            logger.info(f"[AudioStream] Trying Piped fallback for {video_id} (Note: Most public instances currently down)")
            
            for piped_url in piped_instances:
                try:
                    api_url = f"{piped_url}/streams/{video_id}"
                    logger.debug(f"[AudioStream] Testing Piped instance: {piped_url}")
                    
                    async with httpx.AsyncClient(timeout=10.0, follow_redirects=True) as client:
                        response = await client.get(api_url)
                        
                        # Handle redirects (some instances redirect to HTTPS or new URLs)
                        if response.status_code in (301, 302, 307, 308):
                            redirect_url = response.headers.get('Location')
                            if redirect_url:
                                logger.debug(f"[AudioStream] Following redirect: {redirect_url}")
                                if redirect_url.startswith('/'):
                                    redirect_url = f"{piped_url}{redirect_url}"
                                response = await client.get(redirect_url)
                        
                        if response.status_code == 200:
                            try:
                                data = response.json()
                            except Exception as e:
                                logger.debug(f"[AudioStream] Failed to parse JSON from {piped_url}: {e}")
                                continue
                            
                            # Validate we got actual video data
                            if not data.get('title') or not data.get('duration'):
                                logger.debug(f"[AudioStream] Invalid video data from {piped_url}")
                                continue
                            
                            # Extract audio streams
                            audio_streams = data.get('audioStreams', [])
                            if not audio_streams:
                                logger.debug(f"[AudioStream] No audio streams from {piped_url}")
                                continue
                            
                            # Find the best quality audio stream
                            best_audio = max(audio_streams, key=lambda x: x.get('bitrate', 0) or 0)
                            
                            if best_audio and best_audio.get('url'):
                                logger.info(f"[AudioStream] ✓ Piped fallback success from {piped_url} - bitrate: {best_audio.get('bitrate')}, codec: {best_audio.get('codec')}")
                                
                                return {
                                    'url': best_audio['url'],
                                    'format_id': best_audio.get('format', 'piped'),
                                    'ext': best_audio.get('codec', 'unknown'),
                                    'bitrate': best_audio.get('bitrate'),
                                    'duration': data.get('duration'),
                                    'title': data.get('title'),
                                    'strategy': f'piped_fallback ({piped_url})'
                                }
                            else:
                                logger.debug(f"[AudioStream] No valid audio stream found from {piped_url}")
                        
                        else:
                            logger.debug(f"[AudioStream] Piped instance {piped_url} returned HTTP {response.status_code}")
                            
                except httpx.TimeoutException:
                    logger.debug(f"[AudioStream] Timeout connecting to {piped_url}")
                except httpx.ConnectError:
                    logger.debug(f"[AudioStream] Connection failed to {piped_url}")
                except Exception as e:
                    logger.debug(f"[AudioStream] Piped instance {piped_url} error: {e}")
                    continue
            
            logger.warning("[AudioStream] Piped fallback: All tested instances failed or returned no audio streams. This is expected as most public Piped instances are currently down.")
            return None
            
        except Exception as e:
            logger.error(f"[AudioStream] Piped fallback failed with exception: {e}")
            return None
    
    def __del__(self):
        """Cleanup cookie file on deletion"""
        if self.cookie_file and os.path.exists(self.cookie_file.name):
            try:
                os.unlink(self.cookie_file.name)
                logger.info(f"[AudioStream] Cleaned up cookie file")
            except Exception as e:
                logger.error(f"[AudioStream] Failed to cleanup cookie file: {e}")
